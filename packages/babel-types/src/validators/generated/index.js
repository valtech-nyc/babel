// @flow
/*
 * This file is auto-generated! Do not modify it directly.
 * To re-generate run 'make build'
 */
import is from "../is";

export function isArrayExpression(node: Object, opts?: Object): boolean {
  return is("ArrayExpression", node, opts);
}
export function isAssignmentExpression(node: Object, opts?: Object): boolean {
  return is("AssignmentExpression", node, opts);
}
export function isBinaryExpression(node: Object, opts?: Object): boolean {
  return is("BinaryExpression", node, opts);
}
export function isDirective(node: Object, opts?: Object): boolean {
  return is("Directive", node, opts);
}
export function isDirectiveLiteral(node: Object, opts?: Object): boolean {
  return is("DirectiveLiteral", node, opts);
}
export function isBlockStatement(node: Object, opts?: Object): boolean {
  return is("BlockStatement", node, opts);
}
export function isBreakStatement(node: Object, opts?: Object): boolean {
  return is("BreakStatement", node, opts);
}
export function isCallExpression(node: Object, opts?: Object): boolean {
  return is("CallExpression", node, opts);
}
export function isCatchClause(node: Object, opts?: Object): boolean {
  return is("CatchClause", node, opts);
}
export function isConditionalExpression(node: Object, opts?: Object): boolean {
  return is("ConditionalExpression", node, opts);
}
export function isContinueStatement(node: Object, opts?: Object): boolean {
  return is("ContinueStatement", node, opts);
}
export function isDebuggerStatement(node: Object, opts?: Object): boolean {
  return is("DebuggerStatement", node, opts);
}
export function isDoWhileStatement(node: Object, opts?: Object): boolean {
  return is("DoWhileStatement", node, opts);
}
export function isEmptyStatement(node: Object, opts?: Object): boolean {
  return is("EmptyStatement", node, opts);
}
export function isExpressionStatement(node: Object, opts?: Object): boolean {
  return is("ExpressionStatement", node, opts);
}
export function isFile(node: Object, opts?: Object): boolean {
  return is("File", node, opts);
}
export function isForInStatement(node: Object, opts?: Object): boolean {
  return is("ForInStatement", node, opts);
}
export function isForStatement(node: Object, opts?: Object): boolean {
  return is("ForStatement", node, opts);
}
export function isFunctionDeclaration(node: Object, opts?: Object): boolean {
  return is("FunctionDeclaration", node, opts);
}
export function isFunctionExpression(node: Object, opts?: Object): boolean {
  return is("FunctionExpression", node, opts);
}
export function isIdentifier(node: Object, opts?: Object): boolean {
  return is("Identifier", node, opts);
}
export function isIfStatement(node: Object, opts?: Object): boolean {
  return is("IfStatement", node, opts);
}
export function isLabeledStatement(node: Object, opts?: Object): boolean {
  return is("LabeledStatement", node, opts);
}
export function isStringLiteral(node: Object, opts?: Object): boolean {
  return is("StringLiteral", node, opts);
}
export function isNumericLiteral(node: Object, opts?: Object): boolean {
  return is("NumericLiteral", node, opts);
}
export function isNullLiteral(node: Object, opts?: Object): boolean {
  return is("NullLiteral", node, opts);
}
export function isBooleanLiteral(node: Object, opts?: Object): boolean {
  return is("BooleanLiteral", node, opts);
}
export function isRegExpLiteral(node: Object, opts?: Object): boolean {
  return is("RegExpLiteral", node, opts);
}
export function isLogicalExpression(node: Object, opts?: Object): boolean {
  return is("LogicalExpression", node, opts);
}
export function isMemberExpression(node: Object, opts?: Object): boolean {
  return is("MemberExpression", node, opts);
}
export function isNewExpression(node: Object, opts?: Object): boolean {
  return is("NewExpression", node, opts);
}
export function isProgram(node: Object, opts?: Object): boolean {
  return is("Program", node, opts);
}
export function isObjectExpression(node: Object, opts?: Object): boolean {
  return is("ObjectExpression", node, opts);
}
export function isObjectMethod(node: Object, opts?: Object): boolean {
  return is("ObjectMethod", node, opts);
}
export function isObjectProperty(node: Object, opts?: Object): boolean {
  return is("ObjectProperty", node, opts);
}
export function isRestElement(node: Object, opts?: Object): boolean {
  return is("RestElement", node, opts);
}
export function isReturnStatement(node: Object, opts?: Object): boolean {
  return is("ReturnStatement", node, opts);
}
export function isSequenceExpression(node: Object, opts?: Object): boolean {
  return is("SequenceExpression", node, opts);
}
export function isSwitchCase(node: Object, opts?: Object): boolean {
  return is("SwitchCase", node, opts);
}
export function isSwitchStatement(node: Object, opts?: Object): boolean {
  return is("SwitchStatement", node, opts);
}
export function isThisExpression(node: Object, opts?: Object): boolean {
  return is("ThisExpression", node, opts);
}
export function isThrowStatement(node: Object, opts?: Object): boolean {
  return is("ThrowStatement", node, opts);
}
export function isTryStatement(node: Object, opts?: Object): boolean {
  return is("TryStatement", node, opts);
}
export function isUnaryExpression(node: Object, opts?: Object): boolean {
  return is("UnaryExpression", node, opts);
}
export function isUpdateExpression(node: Object, opts?: Object): boolean {
  return is("UpdateExpression", node, opts);
}
export function isVariableDeclaration(node: Object, opts?: Object): boolean {
  return is("VariableDeclaration", node, opts);
}
export function isVariableDeclarator(node: Object, opts?: Object): boolean {
  return is("VariableDeclarator", node, opts);
}
export function isWhileStatement(node: Object, opts?: Object): boolean {
  return is("WhileStatement", node, opts);
}
export function isWithStatement(node: Object, opts?: Object): boolean {
  return is("WithStatement", node, opts);
}
export function isAssignmentPattern(node: Object, opts?: Object): boolean {
  return is("AssignmentPattern", node, opts);
}
export function isArrayPattern(node: Object, opts?: Object): boolean {
  return is("ArrayPattern", node, opts);
}
export function isArrowFunctionExpression(
  node: Object,
  opts?: Object,
): boolean {
  return is("ArrowFunctionExpression", node, opts);
}
export function isClassBody(node: Object, opts?: Object): boolean {
  return is("ClassBody", node, opts);
}
export function isClassDeclaration(node: Object, opts?: Object): boolean {
  return is("ClassDeclaration", node, opts);
}
export function isClassExpression(node: Object, opts?: Object): boolean {
  return is("ClassExpression", node, opts);
}
export function isExportAllDeclaration(node: Object, opts?: Object): boolean {
  return is("ExportAllDeclaration", node, opts);
}
export function isExportDefaultDeclaration(
  node: Object,
  opts?: Object,
): boolean {
  return is("ExportDefaultDeclaration", node, opts);
}
export function isExportNamedDeclaration(node: Object, opts?: Object): boolean {
  return is("ExportNamedDeclaration", node, opts);
}
export function isExportSpecifier(node: Object, opts?: Object): boolean {
  return is("ExportSpecifier", node, opts);
}
export function isForOfStatement(node: Object, opts?: Object): boolean {
  return is("ForOfStatement", node, opts);
}
export function isImportDeclaration(node: Object, opts?: Object): boolean {
  return is("ImportDeclaration", node, opts);
}
export function isImportDefaultSpecifier(node: Object, opts?: Object): boolean {
  return is("ImportDefaultSpecifier", node, opts);
}
export function isImportNamespaceSpecifier(
  node: Object,
  opts?: Object,
): boolean {
  return is("ImportNamespaceSpecifier", node, opts);
}
export function isImportSpecifier(node: Object, opts?: Object): boolean {
  return is("ImportSpecifier", node, opts);
}
export function isMetaProperty(node: Object, opts?: Object): boolean {
  return is("MetaProperty", node, opts);
}
export function isClassMethod(node: Object, opts?: Object): boolean {
  return is("ClassMethod", node, opts);
}
export function isObjectPattern(node: Object, opts?: Object): boolean {
  return is("ObjectPattern", node, opts);
}
export function isSpreadElement(node: Object, opts?: Object): boolean {
  return is("SpreadElement", node, opts);
}
export function isSuper(node: Object, opts?: Object): boolean {
  return is("Super", node, opts);
}
export function isTaggedTemplateExpression(
  node: Object,
  opts?: Object,
): boolean {
  return is("TaggedTemplateExpression", node, opts);
}
export function isTemplateElement(node: Object, opts?: Object): boolean {
  return is("TemplateElement", node, opts);
}
export function isTemplateLiteral(node: Object, opts?: Object): boolean {
  return is("TemplateLiteral", node, opts);
}
export function isYieldExpression(node: Object, opts?: Object): boolean {
  return is("YieldExpression", node, opts);
}
export function isAnyTypeAnnotation(node: Object, opts?: Object): boolean {
  return is("AnyTypeAnnotation", node, opts);
}
export function isArrayTypeAnnotation(node: Object, opts?: Object): boolean {
  return is("ArrayTypeAnnotation", node, opts);
}
export function isBooleanTypeAnnotation(node: Object, opts?: Object): boolean {
  return is("BooleanTypeAnnotation", node, opts);
}
export function isBooleanLiteralTypeAnnotation(
  node: Object,
  opts?: Object,
): boolean {
  return is("BooleanLiteralTypeAnnotation", node, opts);
}
export function isNullLiteralTypeAnnotation(
  node: Object,
  opts?: Object,
): boolean {
  return is("NullLiteralTypeAnnotation", node, opts);
}
export function isClassImplements(node: Object, opts?: Object): boolean {
  return is("ClassImplements", node, opts);
}
export function isDeclareClass(node: Object, opts?: Object): boolean {
  return is("DeclareClass", node, opts);
}
export function isDeclareFunction(node: Object, opts?: Object): boolean {
  return is("DeclareFunction", node, opts);
}
export function isDeclareInterface(node: Object, opts?: Object): boolean {
  return is("DeclareInterface", node, opts);
}
export function isDeclareModule(node: Object, opts?: Object): boolean {
  return is("DeclareModule", node, opts);
}
export function isDeclareModuleExports(node: Object, opts?: Object): boolean {
  return is("DeclareModuleExports", node, opts);
}
export function isDeclareTypeAlias(node: Object, opts?: Object): boolean {
  return is("DeclareTypeAlias", node, opts);
}
export function isDeclareOpaqueType(node: Object, opts?: Object): boolean {
  return is("DeclareOpaqueType", node, opts);
}
export function isDeclareVariable(node: Object, opts?: Object): boolean {
  return is("DeclareVariable", node, opts);
}
export function isDeclareExportDeclaration(
  node: Object,
  opts?: Object,
): boolean {
  return is("DeclareExportDeclaration", node, opts);
}
export function isDeclareExportAllDeclaration(
  node: Object,
  opts?: Object,
): boolean {
  return is("DeclareExportAllDeclaration", node, opts);
}
export function isDeclaredPredicate(node: Object, opts?: Object): boolean {
  return is("DeclaredPredicate", node, opts);
}
export function isExistsTypeAnnotation(node: Object, opts?: Object): boolean {
  return is("ExistsTypeAnnotation", node, opts);
}
export function isFunctionTypeAnnotation(node: Object, opts?: Object): boolean {
  return is("FunctionTypeAnnotation", node, opts);
}
export function isFunctionTypeParam(node: Object, opts?: Object): boolean {
  return is("FunctionTypeParam", node, opts);
}
export function isGenericTypeAnnotation(node: Object, opts?: Object): boolean {
  return is("GenericTypeAnnotation", node, opts);
}
export function isInferredPredicate(node: Object, opts?: Object): boolean {
  return is("InferredPredicate", node, opts);
}
export function isInterfaceExtends(node: Object, opts?: Object): boolean {
  return is("InterfaceExtends", node, opts);
}
export function isInterfaceDeclaration(node: Object, opts?: Object): boolean {
  return is("InterfaceDeclaration", node, opts);
}
export function isIntersectionTypeAnnotation(
  node: Object,
  opts?: Object,
): boolean {
  return is("IntersectionTypeAnnotation", node, opts);
}
export function isMixedTypeAnnotation(node: Object, opts?: Object): boolean {
  return is("MixedTypeAnnotation", node, opts);
}
export function isEmptyTypeAnnotation(node: Object, opts?: Object): boolean {
  return is("EmptyTypeAnnotation", node, opts);
}
export function isNullableTypeAnnotation(node: Object, opts?: Object): boolean {
  return is("NullableTypeAnnotation", node, opts);
}
export function isNumberLiteralTypeAnnotation(
  node: Object,
  opts?: Object,
): boolean {
  return is("NumberLiteralTypeAnnotation", node, opts);
}
export function isNumberTypeAnnotation(node: Object, opts?: Object): boolean {
  return is("NumberTypeAnnotation", node, opts);
}
export function isObjectTypeAnnotation(node: Object, opts?: Object): boolean {
  return is("ObjectTypeAnnotation", node, opts);
}
export function isObjectTypeCallProperty(node: Object, opts?: Object): boolean {
  return is("ObjectTypeCallProperty", node, opts);
}
export function isObjectTypeIndexer(node: Object, opts?: Object): boolean {
  return is("ObjectTypeIndexer", node, opts);
}
export function isObjectTypeProperty(node: Object, opts?: Object): boolean {
  return is("ObjectTypeProperty", node, opts);
}
export function isObjectTypeSpreadProperty(
  node: Object,
  opts?: Object,
): boolean {
  return is("ObjectTypeSpreadProperty", node, opts);
}
export function isOpaqueType(node: Object, opts?: Object): boolean {
  return is("OpaqueType", node, opts);
}
export function isQualifiedTypeIdentifier(
  node: Object,
  opts?: Object,
): boolean {
  return is("QualifiedTypeIdentifier", node, opts);
}
export function isStringLiteralTypeAnnotation(
  node: Object,
  opts?: Object,
): boolean {
  return is("StringLiteralTypeAnnotation", node, opts);
}
export function isStringTypeAnnotation(node: Object, opts?: Object): boolean {
  return is("StringTypeAnnotation", node, opts);
}
export function isThisTypeAnnotation(node: Object, opts?: Object): boolean {
  return is("ThisTypeAnnotation", node, opts);
}
export function isTupleTypeAnnotation(node: Object, opts?: Object): boolean {
  return is("TupleTypeAnnotation", node, opts);
}
export function isTypeofTypeAnnotation(node: Object, opts?: Object): boolean {
  return is("TypeofTypeAnnotation", node, opts);
}
export function isTypeAlias(node: Object, opts?: Object): boolean {
  return is("TypeAlias", node, opts);
}
export function isTypeAnnotation(node: Object, opts?: Object): boolean {
  return is("TypeAnnotation", node, opts);
}
export function isTypeCastExpression(node: Object, opts?: Object): boolean {
  return is("TypeCastExpression", node, opts);
}
export function isTypeParameter(node: Object, opts?: Object): boolean {
  return is("TypeParameter", node, opts);
}
export function isTypeParameterDeclaration(
  node: Object,
  opts?: Object,
): boolean {
  return is("TypeParameterDeclaration", node, opts);
}
export function isTypeParameterInstantiation(
  node: Object,
  opts?: Object,
): boolean {
  return is("TypeParameterInstantiation", node, opts);
}
export function isUnionTypeAnnotation(node: Object, opts?: Object): boolean {
  return is("UnionTypeAnnotation", node, opts);
}
export function isVariance(node: Object, opts?: Object): boolean {
  return is("Variance", node, opts);
}
export function isVoidTypeAnnotation(node: Object, opts?: Object): boolean {
  return is("VoidTypeAnnotation", node, opts);
}
export function isJSXAttribute(node: Object, opts?: Object): boolean {
  return is("JSXAttribute", node, opts);
}
export function isJSXClosingElement(node: Object, opts?: Object): boolean {
  return is("JSXClosingElement", node, opts);
}
export function isJSXElement(node: Object, opts?: Object): boolean {
  return is("JSXElement", node, opts);
}
export function isJSXEmptyExpression(node: Object, opts?: Object): boolean {
  return is("JSXEmptyExpression", node, opts);
}
export function isJSXExpressionContainer(node: Object, opts?: Object): boolean {
  return is("JSXExpressionContainer", node, opts);
}
export function isJSXSpreadChild(node: Object, opts?: Object): boolean {
  return is("JSXSpreadChild", node, opts);
}
export function isJSXIdentifier(node: Object, opts?: Object): boolean {
  return is("JSXIdentifier", node, opts);
}
export function isJSXMemberExpression(node: Object, opts?: Object): boolean {
  return is("JSXMemberExpression", node, opts);
}
export function isJSXNamespacedName(node: Object, opts?: Object): boolean {
  return is("JSXNamespacedName", node, opts);
}
export function isJSXOpeningElement(node: Object, opts?: Object): boolean {
  return is("JSXOpeningElement", node, opts);
}
export function isJSXSpreadAttribute(node: Object, opts?: Object): boolean {
  return is("JSXSpreadAttribute", node, opts);
}
export function isJSXText(node: Object, opts?: Object): boolean {
  return is("JSXText", node, opts);
}
export function isJSXFragment(node: Object, opts?: Object): boolean {
  return is("JSXFragment", node, opts);
}
export function isJSXOpeningFragment(node: Object, opts?: Object): boolean {
  return is("JSXOpeningFragment", node, opts);
}
export function isJSXClosingFragment(node: Object, opts?: Object): boolean {
  return is("JSXClosingFragment", node, opts);
}
export function isNoop(node: Object, opts?: Object): boolean {
  return is("Noop", node, opts);
}
export function isParenthesizedExpression(
  node: Object,
  opts?: Object,
): boolean {
  return is("ParenthesizedExpression", node, opts);
}
export function isAwaitExpression(node: Object, opts?: Object): boolean {
  return is("AwaitExpression", node, opts);
}
export function isBindExpression(node: Object, opts?: Object): boolean {
  return is("BindExpression", node, opts);
}
export function isClassProperty(node: Object, opts?: Object): boolean {
  return is("ClassProperty", node, opts);
}
export function isOptionalMemberExpression(
  node: Object,
  opts?: Object,
): boolean {
  return is("OptionalMemberExpression", node, opts);
}
export function isOptionalCallExpression(node: Object, opts?: Object): boolean {
  return is("OptionalCallExpression", node, opts);
}
export function isImport(node: Object, opts?: Object): boolean {
  return is("Import", node, opts);
}
export function isDecorator(node: Object, opts?: Object): boolean {
  return is("Decorator", node, opts);
}
export function isDoExpression(node: Object, opts?: Object): boolean {
  return is("DoExpression", node, opts);
}
export function isExportDefaultSpecifier(node: Object, opts?: Object): boolean {
  return is("ExportDefaultSpecifier", node, opts);
}
export function isExportNamespaceSpecifier(
  node: Object,
  opts?: Object,
): boolean {
  return is("ExportNamespaceSpecifier", node, opts);
}
export function isTSParameterProperty(node: Object, opts?: Object): boolean {
  return is("TSParameterProperty", node, opts);
}
export function isTSDeclareFunction(node: Object, opts?: Object): boolean {
  return is("TSDeclareFunction", node, opts);
}
export function isTSDeclareMethod(node: Object, opts?: Object): boolean {
  return is("TSDeclareMethod", node, opts);
}
export function isTSQualifiedName(node: Object, opts?: Object): boolean {
  return is("TSQualifiedName", node, opts);
}
export function isTSCallSignatureDeclaration(
  node: Object,
  opts?: Object,
): boolean {
  return is("TSCallSignatureDeclaration", node, opts);
}
export function isTSConstructSignatureDeclaration(
  node: Object,
  opts?: Object,
): boolean {
  return is("TSConstructSignatureDeclaration", node, opts);
}
export function isTSPropertySignature(node: Object, opts?: Object): boolean {
  return is("TSPropertySignature", node, opts);
}
export function isTSMethodSignature(node: Object, opts?: Object): boolean {
  return is("TSMethodSignature", node, opts);
}
export function isTSIndexSignature(node: Object, opts?: Object): boolean {
  return is("TSIndexSignature", node, opts);
}
export function isTSAnyKeyword(node: Object, opts?: Object): boolean {
  return is("TSAnyKeyword", node, opts);
}
export function isTSNumberKeyword(node: Object, opts?: Object): boolean {
  return is("TSNumberKeyword", node, opts);
}
export function isTSObjectKeyword(node: Object, opts?: Object): boolean {
  return is("TSObjectKeyword", node, opts);
}
export function isTSBooleanKeyword(node: Object, opts?: Object): boolean {
  return is("TSBooleanKeyword", node, opts);
}
export function isTSStringKeyword(node: Object, opts?: Object): boolean {
  return is("TSStringKeyword", node, opts);
}
export function isTSSymbolKeyword(node: Object, opts?: Object): boolean {
  return is("TSSymbolKeyword", node, opts);
}
export function isTSVoidKeyword(node: Object, opts?: Object): boolean {
  return is("TSVoidKeyword", node, opts);
}
export function isTSUndefinedKeyword(node: Object, opts?: Object): boolean {
  return is("TSUndefinedKeyword", node, opts);
}
export function isTSNullKeyword(node: Object, opts?: Object): boolean {
  return is("TSNullKeyword", node, opts);
}
export function isTSNeverKeyword(node: Object, opts?: Object): boolean {
  return is("TSNeverKeyword", node, opts);
}
export function isTSThisType(node: Object, opts?: Object): boolean {
  return is("TSThisType", node, opts);
}
export function isTSFunctionType(node: Object, opts?: Object): boolean {
  return is("TSFunctionType", node, opts);
}
export function isTSConstructorType(node: Object, opts?: Object): boolean {
  return is("TSConstructorType", node, opts);
}
export function isTSTypeReference(node: Object, opts?: Object): boolean {
  return is("TSTypeReference", node, opts);
}
export function isTSTypePredicate(node: Object, opts?: Object): boolean {
  return is("TSTypePredicate", node, opts);
}
export function isTSTypeQuery(node: Object, opts?: Object): boolean {
  return is("TSTypeQuery", node, opts);
}
export function isTSTypeLiteral(node: Object, opts?: Object): boolean {
  return is("TSTypeLiteral", node, opts);
}
export function isTSArrayType(node: Object, opts?: Object): boolean {
  return is("TSArrayType", node, opts);
}
export function isTSTupleType(node: Object, opts?: Object): boolean {
  return is("TSTupleType", node, opts);
}
export function isTSUnionType(node: Object, opts?: Object): boolean {
  return is("TSUnionType", node, opts);
}
export function isTSIntersectionType(node: Object, opts?: Object): boolean {
  return is("TSIntersectionType", node, opts);
}
export function isTSConditionalType(node: Object, opts?: Object): boolean {
  return is("TSConditionalType", node, opts);
}
export function isTSInferType(node: Object, opts?: Object): boolean {
  return is("TSInferType", node, opts);
}
export function isTSParenthesizedType(node: Object, opts?: Object): boolean {
  return is("TSParenthesizedType", node, opts);
}
export function isTSTypeOperator(node: Object, opts?: Object): boolean {
  return is("TSTypeOperator", node, opts);
}
export function isTSIndexedAccessType(node: Object, opts?: Object): boolean {
  return is("TSIndexedAccessType", node, opts);
}
export function isTSMappedType(node: Object, opts?: Object): boolean {
  return is("TSMappedType", node, opts);
}
export function isTSLiteralType(node: Object, opts?: Object): boolean {
  return is("TSLiteralType", node, opts);
}
export function isTSExpressionWithTypeArguments(
  node: Object,
  opts?: Object,
): boolean {
  return is("TSExpressionWithTypeArguments", node, opts);
}
export function isTSInterfaceDeclaration(node: Object, opts?: Object): boolean {
  return is("TSInterfaceDeclaration", node, opts);
}
export function isTSInterfaceBody(node: Object, opts?: Object): boolean {
  return is("TSInterfaceBody", node, opts);
}
export function isTSTypeAliasDeclaration(node: Object, opts?: Object): boolean {
  return is("TSTypeAliasDeclaration", node, opts);
}
export function isTSAsExpression(node: Object, opts?: Object): boolean {
  return is("TSAsExpression", node, opts);
}
export function isTSTypeAssertion(node: Object, opts?: Object): boolean {
  return is("TSTypeAssertion", node, opts);
}
export function isTSEnumDeclaration(node: Object, opts?: Object): boolean {
  return is("TSEnumDeclaration", node, opts);
}
export function isTSEnumMember(node: Object, opts?: Object): boolean {
  return is("TSEnumMember", node, opts);
}
export function isTSModuleDeclaration(node: Object, opts?: Object): boolean {
  return is("TSModuleDeclaration", node, opts);
}
export function isTSModuleBlock(node: Object, opts?: Object): boolean {
  return is("TSModuleBlock", node, opts);
}
export function isTSImportEqualsDeclaration(
  node: Object,
  opts?: Object,
): boolean {
  return is("TSImportEqualsDeclaration", node, opts);
}
export function isTSExternalModuleReference(
  node: Object,
  opts?: Object,
): boolean {
  return is("TSExternalModuleReference", node, opts);
}
export function isTSNonNullExpression(node: Object, opts?: Object): boolean {
  return is("TSNonNullExpression", node, opts);
}
export function isTSExportAssignment(node: Object, opts?: Object): boolean {
  return is("TSExportAssignment", node, opts);
}
export function isTSNamespaceExportDeclaration(
  node: Object,
  opts?: Object,
): boolean {
  return is("TSNamespaceExportDeclaration", node, opts);
}
export function isTSTypeAnnotation(node: Object, opts?: Object): boolean {
  return is("TSTypeAnnotation", node, opts);
}
export function isTSTypeParameterInstantiation(
  node: Object,
  opts?: Object,
): boolean {
  return is("TSTypeParameterInstantiation", node, opts);
}
export function isTSTypeParameterDeclaration(
  node: Object,
  opts?: Object,
): boolean {
  return is("TSTypeParameterDeclaration", node, opts);
}
export function isTSTypeParameter(node: Object, opts?: Object): boolean {
  return is("TSTypeParameter", node, opts);
}
export function isExpression(node: Object, opts?: Object): boolean {
  return is("Expression", node, opts);
}
export function isBinary(node: Object, opts?: Object): boolean {
  return is("Binary", node, opts);
}
export function isScopable(node: Object, opts?: Object): boolean {
  return is("Scopable", node, opts);
}
export function isBlockParent(node: Object, opts?: Object): boolean {
  return is("BlockParent", node, opts);
}
export function isBlock(node: Object, opts?: Object): boolean {
  return is("Block", node, opts);
}
export function isStatement(node: Object, opts?: Object): boolean {
  return is("Statement", node, opts);
}
export function isTerminatorless(node: Object, opts?: Object): boolean {
  return is("Terminatorless", node, opts);
}
export function isCompletionStatement(node: Object, opts?: Object): boolean {
  return is("CompletionStatement", node, opts);
}
export function isConditional(node: Object, opts?: Object): boolean {
  return is("Conditional", node, opts);
}
export function isLoop(node: Object, opts?: Object): boolean {
  return is("Loop", node, opts);
}
export function isWhile(node: Object, opts?: Object): boolean {
  return is("While", node, opts);
}
export function isExpressionWrapper(node: Object, opts?: Object): boolean {
  return is("ExpressionWrapper", node, opts);
}
export function isFor(node: Object, opts?: Object): boolean {
  return is("For", node, opts);
}
export function isForXStatement(node: Object, opts?: Object): boolean {
  return is("ForXStatement", node, opts);
}
export function isFunction(node: Object, opts?: Object): boolean {
  return is("Function", node, opts);
}
export function isFunctionParent(node: Object, opts?: Object): boolean {
  return is("FunctionParent", node, opts);
}
export function isPureish(node: Object, opts?: Object): boolean {
  return is("Pureish", node, opts);
}
export function isDeclaration(node: Object, opts?: Object): boolean {
  return is("Declaration", node, opts);
}
export function isPatternLike(node: Object, opts?: Object): boolean {
  return is("PatternLike", node, opts);
}
export function isLVal(node: Object, opts?: Object): boolean {
  return is("LVal", node, opts);
}
export function isTSEntityName(node: Object, opts?: Object): boolean {
  return is("TSEntityName", node, opts);
}
export function isLiteral(node: Object, opts?: Object): boolean {
  return is("Literal", node, opts);
}
export function isImmutable(node: Object, opts?: Object): boolean {
  return is("Immutable", node, opts);
}
export function isUserWhitespacable(node: Object, opts?: Object): boolean {
  return is("UserWhitespacable", node, opts);
}
export function isMethod(node: Object, opts?: Object): boolean {
  return is("Method", node, opts);
}
export function isObjectMember(node: Object, opts?: Object): boolean {
  return is("ObjectMember", node, opts);
}
export function isProperty(node: Object, opts?: Object): boolean {
  return is("Property", node, opts);
}
export function isUnaryLike(node: Object, opts?: Object): boolean {
  return is("UnaryLike", node, opts);
}
export function isPattern(node: Object, opts?: Object): boolean {
  return is("Pattern", node, opts);
}
export function isClass(node: Object, opts?: Object): boolean {
  return is("Class", node, opts);
}
export function isModuleDeclaration(node: Object, opts?: Object): boolean {
  return is("ModuleDeclaration", node, opts);
}
export function isExportDeclaration(node: Object, opts?: Object): boolean {
  return is("ExportDeclaration", node, opts);
}
export function isModuleSpecifier(node: Object, opts?: Object): boolean {
  return is("ModuleSpecifier", node, opts);
}
export function isFlow(node: Object, opts?: Object): boolean {
  return is("Flow", node, opts);
}
export function isFlowType(node: Object, opts?: Object): boolean {
  return is("FlowType", node, opts);
}
export function isFlowBaseAnnotation(node: Object, opts?: Object): boolean {
  return is("FlowBaseAnnotation", node, opts);
}
export function isFlowDeclaration(node: Object, opts?: Object): boolean {
  return is("FlowDeclaration", node, opts);
}
export function isFlowPredicate(node: Object, opts?: Object): boolean {
  return is("FlowPredicate", node, opts);
}
export function isJSX(node: Object, opts?: Object): boolean {
  return is("JSX", node, opts);
}
export function isTSTypeElement(node: Object, opts?: Object): boolean {
  return is("TSTypeElement", node, opts);
}
export function isTSType(node: Object, opts?: Object): boolean {
  return is("TSType", node, opts);
}
export function isNumberLiteral(node: Object, opts: Object): boolean {
  console.trace(
    "The node type NumberLiteral has been renamed to NumericLiteral",
  );
  return is("NumberLiteral", node, opts);
}
export function isRegexLiteral(node: Object, opts: Object): boolean {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  return is("RegexLiteral", node, opts);
}
export function isRestProperty(node: Object, opts: Object): boolean {
  console.trace("The node type RestProperty has been renamed to RestElement");
  return is("RestProperty", node, opts);
}
export function isSpreadProperty(node: Object, opts: Object): boolean {
  console.trace(
    "The node type SpreadProperty has been renamed to SpreadElement",
  );
  return is("SpreadProperty", node, opts);
}
